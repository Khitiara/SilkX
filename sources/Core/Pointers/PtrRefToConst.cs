// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.

// ============================================= THIS FILE IS AUTOGENERATED ============================================
// =============================== Please make any edits in eng/pointergen/Generator.cs! ===============================
// ============================================= THIS FILE IS AUTOGENERATED ============================================

using System.Diagnostics.CodeAnalysis;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Text;

namespace Silk.NET.Core;

/// <summary>
/// A single dimension pointer wrapper
/// </summary>
public readonly ref struct PtrRefToConst
{
    /// <summary>
    /// Creates a pointer with the given underlying ref.
    /// </summary>
    /// <param name="Ref">The underlying ref.</param>
    public PtrRefToConst(ref readonly byte @Ref)
    {
        this.Ref = ref @Ref;
    }

    /// <summary>
    /// The underlying reference.
    /// </summary>
    public readonly ref readonly byte Ref;

    /// <summary>
    /// Gets the item at the given offset from this pointer.
    /// </summary>
    /// <param name="index">The index.</param>
    public ref readonly byte this[nuint index]
    {
        [MethodImpl(
        MethodImplOptions.AggressiveInlining | MethodImplOptions.AggressiveOptimization
    )]
        get => ref Unsafe.Add(ref Unsafe.AsRef(in Ref), index);
    }

    /// <summary>
    /// Gets the underlying reference.
    /// </summary>
    /// <returns>The underlying reference.</returns>
    /// <remarks>
    /// This function allows a <see cref="PtrRefToConst"/> to be used in a <c>fixed</c> statement.
    /// </remarks>
    public ref readonly byte GetPinnableReference() => ref Ref;

    /// <summary>
    /// Creates a span with the given length from this pointer.
    /// </summary>
    /// <param name="length">the span length</param>
    /// <returns>the span</returns>
    public ReadOnlySpan<byte> AsSpan(int length) => MemoryMarshal.CreateReadOnlySpan(ref Unsafe.AsRef(in Ref), length);

    /// <summary>
    /// Determines if this <see cref="PtrRefToConst"/> equals another object
    /// Always returns false as ref structs cannot be passed in, meaning this will never be true
    /// </summary>
    /// <param name="obj"></param>
    /// <returns>Whether this object is the same as </returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining | MethodImplOptions.AggressiveOptimization)]
    public override bool Equals([NotNullWhen(true)] object? obj) => false;

    /// <inheritdoc />
    [MethodImpl(MethodImplOptions.AggressiveInlining | MethodImplOptions.AggressiveOptimization)]
    public override int GetHashCode() => Ref.GetHashCode();

    /// <summary>
    /// Determines if two <see cref="PtrRefToConst"/> objects are equivalent
    /// </summary>
    /// <param name="lh"></param>
    /// <param name="rh"></param>
    /// <returns>Whether the pointers are equal</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining | MethodImplOptions.AggressiveOptimization)]
    public unsafe static bool operator ==(PtrRefToConst lh, PtrRefToConst rh) => (void*)lh == (void*)rh;

    /// <summary>
    /// Determines if two <see cref="PtrRefToConst"/> objects are not equivalent
    /// </summary>
    /// <param name="lh"></param>
    /// <param name="rh"></param>
    /// <returns>Whether the pointers are not equal</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining | MethodImplOptions.AggressiveOptimization)]
    public unsafe static bool operator !=(PtrRefToConst lh, PtrRefToConst rh) => (void*)lh != (void*)rh;

    /// <summary>
    /// Creates a <see cref="PtrRefToConst"/> from a Nullptr
    /// </summary>
    /// <param name="ptr"></param>
    [MethodImpl(MethodImplOptions.AggressiveInlining | MethodImplOptions.AggressiveOptimization)]
    public unsafe static implicit operator PtrRefToConst(NullPtr ptr) => (void*)ptr;

    /// <summary>
    /// Determines whether a <see cref="PtrRefToConst"/> and a NullPtr are equal
    /// </summary>
    /// <param name="lh"></param>
    /// <param name="rh"></param>
    /// <returns>Whether the <see cref="PtrRefToConst"/> and NullPtr are equal</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining | MethodImplOptions.AggressiveOptimization)]
    public static bool operator ==(PtrRefToConst lh, NullPtr rh) => lh == (PtrRefToConst)rh;

    /// <summary>
    /// Determines whether a <see cref="PtrRefToConst"/> and a NullPtr are not equal
    /// </summary>
    /// <param name="lh"></param>
    /// <param name="rh"></param>
    /// <returns>Whether the <see cref="PtrRefToConst"/> and NullPtr are not equal</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining | MethodImplOptions.AggressiveOptimization)]
    public static bool operator !=(PtrRefToConst lh, NullPtr rh) => lh != (PtrRefToConst)rh;

    /// <summary>
    /// Determines whether a NullPtr and a <see cref="PtrRefToConst"/> are equal
    /// </summary>
    /// <param name="lh"></param>
    /// <param name="rh"></param>
    /// <returns>Whether the NullPtr and <see cref="PtrRefToConst"/> are equal</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining | MethodImplOptions.AggressiveOptimization)]
    public static bool operator ==(NullPtr lh, PtrRefToConst rh) => (PtrRefToConst)lh == rh;

    /// <summary>
    /// Determines whether a NullPtr and a <see cref="PtrRefToConst"/> are not equal
    /// </summary>
    /// <param name="lh"></param>
    /// <param name="rh"></param>
    /// <returns>Whether the NullPtr and <see cref="PtrRefToConst"/> are not equal</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining | MethodImplOptions.AggressiveOptimization)]
    public static bool operator !=(NullPtr lh, PtrRefToConst rh) => (PtrRefToConst)lh != rh;

    /// <summary>
    /// Creates a <see cref="PtrRefToConst"/> from a span
    /// </summary>
    /// <param name="span"></param>
    [MethodImpl(MethodImplOptions.AggressiveInlining | MethodImplOptions.AggressiveOptimization)]
    public static implicit operator PtrRefToConst(Span<byte> span) => new(ref span.GetPinnableReference());

    /// <summary>
    /// Creates a <see cref="PtrRefToConst"/> from a byte pointer
    /// </summary>
    /// <param name="ptr"></param>
    [MethodImpl(MethodImplOptions.AggressiveInlining | MethodImplOptions.AggressiveOptimization)]
    public unsafe static implicit operator PtrRefToConst(byte* ptr) => new(ref Unsafe.AsRef<byte>(ptr));

    /// <summary>
    /// Creates a <see cref="PtrRefToConst"/> from a void pointer
    /// </summary>
    /// <param name="ptr"></param>
    [MethodImpl(MethodImplOptions.AggressiveInlining | MethodImplOptions.AggressiveOptimization)]
    public unsafe static implicit operator PtrRefToConst(void* ptr) => new(ref Unsafe.AsRef<byte>(ptr));

    /// <summary>
    /// Creates a byte pointer from a <see cref="PtrRefToConst"/>
    /// </summary>
    /// <param name="ptr"></param>
    [MethodImpl(MethodImplOptions.AggressiveInlining | MethodImplOptions.AggressiveOptimization)]
    public unsafe static explicit operator byte*(PtrRefToConst ptr) => (byte*)Unsafe.AsPointer(ref Unsafe.AsRef(in ptr.Ref));

    /// <summary>
    /// Creates a void pointer from a <see cref="PtrRefToConst"/>
    /// </summary>
    /// <param name="ptr"></param>
    [MethodImpl(MethodImplOptions.AggressiveInlining | MethodImplOptions.AggressiveOptimization)]
    public unsafe static explicit operator void*(PtrRefToConst ptr) => Unsafe.AsPointer(ref Unsafe.AsRef(in ptr.Ref));

    /// <summary>
    /// creates a <see cref="PtrRefToConst"/> from an array
    /// </summary>
    /// <param name="array"></param>
    [MethodImpl(MethodImplOptions.AggressiveInlining | MethodImplOptions.AggressiveOptimization)]
    public static implicit operator PtrRefToConst(byte[] array) => array.AsSpan();

    /// <summary>
    /// creates a <see cref="PtrRefToConst"/> from a 2D array
    /// </summary>
    /// <param name="array"></param>
    [MethodImpl(MethodImplOptions.AggressiveInlining | MethodImplOptions.AggressiveOptimization)]
    public static implicit operator PtrRefToConst(byte[,] array) => MemoryMarshal.CreateSpan(ref array[0, 0], array.Length);

    /// <summary>
    /// creates a <see cref="PtrRefToConst"/> from a 3D array
    /// </summary>
    /// <param name="array"></param>
    [MethodImpl(MethodImplOptions.AggressiveInlining | MethodImplOptions.AggressiveOptimization)]
    public static implicit operator PtrRefToConst(byte[,,] array) => MemoryMarshal.CreateSpan(ref array[0, 0, 0], array.Length);

    /// <summary>
    /// Creates a string from this <see cref="PtrRefToConst"/> with the given length
    /// </summary>
    /// <param name="length">length of the string</param>
    /// <returns>the string</returns>
    public unsafe string ReadToString(int length) => Encoding.UTF8.GetString(AsSpan(length));

    /// <summary>
    /// Creates a string from this <see cref="PtrRefToConst"/> as a c-style string
    /// </summary>
    /// <returns>the string</returns>
    public unsafe string ReadToString()
    {
        return Encoding.UTF8.GetString(
            MemoryMarshal.CreateReadOnlySpanFromNullTerminated(
                (byte*)Unsafe.AsPointer(ref Unsafe.AsRef(in Ref))));
    }

    /// <summary>
    /// Creates a string from a <see cref="PtrRefToConst"/>
    /// </summary>
    /// <param name="ptr"></param>
    [MethodImpl(MethodImplOptions.AggressiveInlining | MethodImplOptions.AggressiveOptimization)]
    public static explicit operator string(PtrRefToConst ptr) => ptr.ReadToString();

    /// <summary>
    /// Creates a <see cref="PtrRefToConst"/> from a ReadOnlySpan
    /// </summary>
    /// <param name="span"></param>
    [MethodImpl(MethodImplOptions.AggressiveInlining | MethodImplOptions.AggressiveOptimization)]
    public static implicit operator PtrRefToConst(ReadOnlySpan<byte> span) => new(in span.GetPinnableReference());
}
